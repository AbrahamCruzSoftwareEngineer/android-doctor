package com.evolutiondso.androiddoctor

import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import java.time.Instant

abstract class AndroidDoctorCollectTask : DefaultTask() {

    @get:OutputFile
    abstract val reportFile: RegularFileProperty

    init {
        group = "verification"
        description = "Collect AndroidDoctor diagnostics (writes a basic report.json)."
    }

    @TaskAction
    fun run() {
        val file = reportFile.get().asFile
        file.parentFile.mkdirs()

        val now = Instant.now().toString()
        val projectName = project.name
        val projectPath = project.path
        val gradleVersion = project.gradle.gradleVersion
        val kotlinStdlibVersion = KotlinVersion.CURRENT.toString()
        val pluginVersion = ANDROID_DOCTOR_VERSION

        // Android detection
        val isAndroidApplication = project.plugins.hasPlugin("com.android.application")
        val isAndroidLibrary = project.plugins.hasPlugin("com.android.library")
        val isAndroidProject = isAndroidApplication || isAndroidLibrary

        // kapt usage
        val hasKaptPlugin =
            project.plugins.hasPlugin("org.jetbrains.kotlin.kapt") ||
                    project.plugins.hasPlugin("kotlin-kapt")

        val hasKaptConfiguration =
            project.configurations.names.any { name ->
                name.startsWith("kapt", ignoreCase = true)
            }

        val usesKapt = hasKaptPlugin || hasKaptConfiguration

        // Root + module count
        val isRootProject = (project == project.rootProject)
        val moduleCount = project.rootProject.allprojects.size

        // Config cache status
        val configurationCacheEnabled: Boolean? = readConfigurationCacheEnabledOrNull(project)

        // Android signals (safe reflection)
        val agpVersion = readAgpVersionOrNull()
        val composeEnabled = readComposeEnabledOrNull(project)

        // Compute scores
        val scores = computeScores(
            isAndroidProject = isAndroidProject,
            usesKapt = usesKapt,
            moduleCount = moduleCount,
            configurationCacheEnabled = configurationCacheEnabled,
            composeEnabled = composeEnabled
        )

        // Known plugins
        val knownPluginIds = listOf(
            "com.android.application",
            "com.android.library",
            "org.jetbrains.kotlin.android",
            "org.jetbrains.kotlin.jvm",
            "org.jetbrains.kotlin.plugin.serialization",
            "org.jetbrains.kotlin.kapt",
            "kotlin-kapt",
            "dagger.hilt.android.plugin",
            "com.google.dagger.hilt.android"
        )

        val appliedKnownPluginIds = knownPluginIds.filter { project.plugins.hasPlugin(it) }
        val appliedKnownPluginsJson = appliedKnownPluginIds.joinToString { "\"$it\"" }

        // Recommended actions
        val actions = buildTopActions(
            moduleCount = moduleCount,
            usesKapt = usesKapt,
            configurationCacheEnabled = configurationCacheEnabled,
            isAndroidProject = isAndroidProject,
            composeEnabled = composeEnabled
        )

        val actionsJson = actionsToJson(actions)

        val agpVersionJson = agpVersion?.let { "\"$it\"" } ?: "null"
        val composeEnabledJson = composeEnabled?.toString() ?: "null"
        val configCacheJson = configurationCacheEnabled?.toString() ?: "null"

        // ---------- CLEAN JSON (NO LEADING INDENTATION) ----------
        val json = """
{
  "schemaVersion": 1,
  "generatedAt": "$now",
  "project": {
    "name": "$projectName",
    "path": "$projectPath"
  },
  "tooling": {
    "gradleVersion": "$gradleVersion",
    "kotlinStdlibVersion": "$kotlinStdlibVersion",
    "androidDoctorPluginVersion": "$pluginVersion"
  },
  "status": "skeleton",
  "checks": {
    "isAndroidApplication": $isAndroidApplication,
    "isAndroidLibrary": $isAndroidLibrary,
    "isAndroidProject": $isAndroidProject,
    "usesKapt": $usesKapt,
    "isRootProject": $isRootProject,
    "moduleCount": $moduleCount,
    "configurationCacheEnabled": $configCacheJson
  },
  "android": {
    "agpVersion": $agpVersionJson,
    "composeEnabled": $composeEnabledJson
  },
  "scores": {
    "buildHealth": ${scores.buildHealth},
    "modernization": ${scores.modernization}
  },
  "actions": $actionsJson,
  "plugins": {
    "appliedKnownPluginIds": [ $appliedKnownPluginsJson ]
  },
  "notes": [
    "This report is generated by the AndroidDoctor Gradle plugin skeleton.",
    "Fields and structure will evolve; do not rely on this format yet."
  ]
}
        """.trimIndent()

        // Pretty: add final newline so the terminal doesn't show "%".
        file.writeText(json + "\n")

        logger.lifecycle("AndroidDoctor: report written to ${file.absolutePath}")
    }
}

// ---------------------------------------------------------------------------
// Score Model
// ---------------------------------------------------------------------------

private data class Scores(
    val buildHealth: Int,
    val modernization: Int
)

private fun computeScores(
    isAndroidProject: Boolean,
    usesKapt: Boolean,
    moduleCount: Int,
    configurationCacheEnabled: Boolean?,
    composeEnabled: Boolean?
): Scores {
    var build = 100

    when (configurationCacheEnabled) {
        true -> Unit
        false -> build -= 10
        null -> build -= 3
    }

    if (usesKapt) build -= 20
    if (moduleCount <= 1) build -= 10
    build = build.coerceIn(0, 100)

    var modern = 100

    when (configurationCacheEnabled) {
        true -> Unit
        false -> modern -= 5
        null -> modern -= 2
    }

    if (usesKapt) modern -= 10

    if (isAndroidProject) {
        when (composeEnabled) {
            true -> Unit
            false -> modern -= 10
            null -> modern -= 3
        }
    }

    modern = modern.coerceIn(0, 100)

    return Scores(buildHealth = build, modernization = modern)
}

// ---------------------------------------------------------------------------
// Action Model
// ---------------------------------------------------------------------------

private data class Impact(val buildHealthDelta: Int, val modernizationDelta: Int)

private data class Action(
    val id: String,
    val priority: Int,
    val severity: String,
    val effort: String,
    val title: String,
    val why: String,
    val how: String,
    val impact: Impact
)

private fun buildTopActions(
    moduleCount: Int,
    usesKapt: Boolean,
    configurationCacheEnabled: Boolean?,
    isAndroidProject: Boolean,
    composeEnabled: Boolean?
): List<Action> {

    val actions = mutableListOf<Action>()

    // Monolithic build
    if (moduleCount <= 1) {
        actions += Action(
            id = "MODULARIZE_MONOLITH",
            priority = 1,
            severity = "HIGH",
            effort = "M",
            title = "Consider modularizing the build",
            why = "Single-module builds often get slower as code grows and reduce parallelism.",
            how = "Start by extracting a :core module, then move one feature into its own module.",
            impact = Impact(10, 0)
        )
    }

    // Configuration cache
    when (configurationCacheEnabled) {
        false -> actions += Action(
            id = "ENABLE_CONFIGURATION_CACHE",
            priority = 1,
            severity = "HIGH",
            effort = "S",
            title = "Enable Gradle configuration cache",
            why = "Configuration cache can significantly reduce configuration time on repeated builds.",
            how = "Enable it, run a build, then fix incompatibilities reported by Gradle. Consider org.gradle.configuration-cache=true.",
            impact = Impact(10, 5)
        )

        null -> actions += Action(
            id = "VERIFY_CONFIGURATION_CACHE",
            priority = 2,
            severity = "MEDIUM",
            effort = "S",
            title = "Verify configuration cache support",
            why = "AndroidDoctor could not determine if configuration cache is enabled for this build.",
            how = "Try enabling it and confirming it’s effective; then consider opting in via gradle.properties.",
            impact = Impact(3, 2)
        )

        true -> Unit
    }

    // kapt → KSP
    if (usesKapt) {
        actions += Action(
            id = "MIGRATE_KAPT_TO_KSP",
            priority = 2,
            severity = "MEDIUM",
            effort = "M",
            title = "Consider migrating kapt to KSP",
            why = "kapt can slow builds due to Java stub generation and annotation processing overhead.",
            how = "Where supported, migrate libraries to KSP and remove kapt usage incrementally.",
            impact = Impact(20, 10)
        )
    }

    // Compose detection
    if (isAndroidProject) {
        when (composeEnabled) {
            false -> actions += Action(
                id = "EVALUATE_COMPOSE_ADOPTION",
                priority = 3,
                severity = "LOW",
                effort = "M",
                title = "Evaluate adopting Jetpack Compose for new UI",
                why = "Compose can improve UI iteration speed and reduce XML complexity over time.",
                how = "Start with new screens or isolated components; keep migration incremental and measurable.",
                impact = Impact(0, 10)
            )

            null -> actions += Action(
                id = "DETECT_COMPOSE_CONFIGURATION",
                priority = 3,
                severity = "LOW",
                effort = "S",
                title = "Confirm Compose configuration",
                why = "AndroidDoctor could not determine whether Compose is enabled.",
                how = "Check android.buildFeatures.compose and your Compose compiler configuration.",
                impact = Impact(0, 3)
            )

            true -> Unit
        }
    }

    return actions
        .sortedWith(compareBy<Action> { it.priority }.thenBy { it.id })
        .take(5)
}

private fun actionsToJson(actions: List<Action>): String {
    if (actions.isEmpty()) return "[]"

    fun esc(s: String): String =
        s.replace("\\", "\\\\").replace("\"", "\\\"")

    val items = actions.joinToString(",\n") { a ->
        """
        {
          "id": "${esc(a.id)}",
          "priority": ${a.priority},
          "severity": "${esc(a.severity)}",
          "effort": "${esc(a.effort)}",
          "title": "${esc(a.title)}",
          "why": "${esc(a.why)}",
          "how": "${esc(a.how)}",
          "impact": {
            "buildHealthDelta": ${a.impact.buildHealthDelta},
            "modernizationDelta": ${a.impact.modernizationDelta}
          }
        }
        """.trimIndent()
    }

    return "[\n$items\n]"
}

// ---------------------------------------------------------------------------
// Reflection helpers
// ---------------------------------------------------------------------------

private fun readAgpVersionOrNull(): String? {
    return try {
        val clazz = Class.forName("com.android.Version")
        val field = clazz.getField("ANDROID_GRADLE_PLUGIN_VERSION")
        field[null]?.toString()
    } catch (_: Throwable) {
        null
    }
}

private fun readComposeEnabledOrNull(project: Project): Boolean? {
    val androidExt = project.extensions.findByName("android") ?: return null

    return try {
        val getBuildFeatures =
            androidExt.javaClass.methods.firstOrNull { it.name == "getBuildFeatures" }
                ?: return null

        val buildFeatures = getBuildFeatures.invoke(androidExt) ?: return null

        val getCompose =
            buildFeatures.javaClass.methods.firstOrNull { it.name == "getCompose" }
                ?: return null

        getCompose.invoke(buildFeatures) as? Boolean
    } catch (_: Throwable) {
        null
    }
}

private fun readConfigurationCacheEnabledOrNull(project: Project): Boolean? {
    return try {
        val gradle = project.gradle

        val getBuildFeatures =
            gradle.javaClass.methods.firstOrNull { it.name == "getBuildFeatures" }
                ?: return null

        val buildFeatures = getBuildFeatures.invoke(gradle) ?: return null

        val getConfigurationCache =
            buildFeatures.javaClass.methods.firstOrNull { it.name == "getConfigurationCache" }
                ?: return null

        val configCacheFeature = getConfigurationCache.invoke(buildFeatures) ?: return null

        val enabledMethod =
            configCacheFeature.javaClass.methods.firstOrNull {
                it.parameterCount == 0 &&
                        (it.name == "isEnabled" || it.name == "getEnabled")
            } ?: return null

        enabledMethod.invoke(configCacheFeature) as? Boolean
    } catch (_: Throwable) {
        null
    }
}
